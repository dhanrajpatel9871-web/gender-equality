const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const cors = require('cors');
const bodyParser = require('body-parser');

const app = express();
app.use(cors());
app.use(bodyParser.json());

// Secret for JWT
const JWT_SECRET = 'your_jwt_secret_here';

// Simulated database (replace with real DB in production)
const users = {}; // username -> { passwordHash, balance, bets }

// Helper: Generate JWT
function generateToken(username) {
  return jwt.sign({ username }, JWT_SECRET, { expiresIn: '1d' });
}

// Middleware: Authenticate JWT
function authenticateToken(req, res, next) {
  const token = req.headers['authorization']?.split(" ")[1];
  if (!token) return res.sendStatus(401);
  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}

// User registration
app.post('/api/register', async (req, res) => {
  const { username, password } = req.body;
  if (users[username]) return res.status(400).json({ error: 'User already exists' });
  const passwordHash = await bcrypt.hash(password, 10);
  users[username] = { passwordHash, balance: 1000, bets: [] }; // Starting balance: 1000 mock tokens
  res.json({ message: 'User registered' });
});

// User login
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users[username];
  if (!user) return res.status(400).json({ error: 'User not found' });
  const match = await bcrypt.compare(password, user.passwordHash);
  if (!match) return res.status(400).json({ error: 'Invalid password' });
  const token = generateToken(username);
  res.json({ token, balance: user.balance });
});

// Get user dashboard info
app.get('/api/dashboard', authenticateToken, (req, res) => {
  const user = users[req.user.username];
  if (!user) return res.status(404).json({ error: 'User not found' });
  res.json({ balance: user.balance, bets: user.bets });
});

// Provably fair dice game logic (simplified):
// User provides a "clientSeed", server produces "serverSeed" & "nonce"
// Dice roll formula: (hash(serverSeed + nonce + clientSeed) mod 100) + 1
const crypto = require('crypto');

function sha256(input) {
  return crypto.createHash('sha256').update(input).digest('hex');
}

app.post('/api/bet', authenticateToken, (req, res) => {
  const user = users[req.user.username];
  if (!user) return res.status(404).json({ error: 'User not found' });
  const { amount, clientSeed, guess } = req.body;
  if (amount <= 0 || amount > user.balance) return res.status(400).json({ error: 'Invalid bet amount' });
  if (guess < 1 || guess > 100) return res.status(400).json({ error: 'Guess must be between 1 and 100' });

  const serverSeed = crypto.randomBytes(16).toString('hex');
  const nonce = 1; // Can increment on each bet for real fairness
  const rollHash = sha256(serverSeed + nonce + clientSeed);
  const roll = (parseInt(rollHash.slice(0, 8), 16) % 100) + 1;

  let win = false;
  let payout = 0;
  if (roll <= guess) {
    payout = (99 / guess) * amount; // Payout odds
    user.balance += payout;
    win = true;
  } else {
    user.balance -= amount;
  }

  const betResult = {
    serverSeed,
    clientSeed,
    nonce,
    roll,
    guess,
    amount,
    win,
    payout: payout.toFixed(2),
    timestamp: new Date()
  };

  user.bets.push(betResult);

  res.json({ betResult, balance: user.balance });
});

const port = 4000;
app.listen(port, () => {
  console.log(`Server running on http://localhost:${port}`);
});
